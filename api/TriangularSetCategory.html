
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TriangularSetCategory(R, E, V, P) &#8212; FriCAS dc27d6f8d24fbb7a59b9b1c208e5ea960b3943d8</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TrigonometricFunctionCategory" href="TrigonometricFunctionCategory.html" />
    <link rel="prev" title="TranscendentalFunctionCategory" href="TranscendentalFunctionCategory.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="TrigonometricFunctionCategory.html" title="TrigonometricFunctionCategory"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="TranscendentalFunctionCategory.html" title="TranscendentalFunctionCategory"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS dc27d6f8d24fbb7a59b9b1c208e5ea960b3943d8</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Categories.html" accesskey="U">Categories</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">TriangularSetCategory(R, E, V, P)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="triangularsetcategory-r-e-v-p">
<span id="l-triangular-set-category"></span><span id="index-0"></span><h1>TriangularSetCategory(R, E, V, P)<a class="headerlink" href="#triangularsetcategory-r-e-v-p" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://github.com/hemmecke/fricas/blob/formatted/src/algebra/triset.spad#L1">triset.spad line 1</a> <a class="reference external" href="https://github.com/hemmecke/fricas/edit/formatted/src/algebra/triset.spad#L1">[edit on github]</a></p>
<ul class="simple">
<li><p>R: <a class="reference internal" href="IntegralDomain.html#l-integral-domain"><span class="std std-ref">IntegralDomain</span></a></p></li>
<li><p>E: <a class="reference internal" href="OrderedAbelianMonoidSup.html#l-ordered-abelian-monoid-sup"><span class="std std-ref">OrderedAbelianMonoidSup</span></a></p></li>
<li><p>V: <a class="reference internal" href="OrderedSet.html#l-ordered-set"><span class="std std-ref">OrderedSet</span></a></p></li>
<li><p>P: <a class="reference internal" href="RecursivePolynomialCategory.html#l-recursive-polynomial-category"><span class="std std-ref">RecursivePolynomialCategory</span></a>(R, E, V)</p></li>
</ul>
<p>The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let <code class="docutils literal notranslate"><span class="pre">R</span></code> be an integral domain and <code class="docutils literal notranslate"><span class="pre">V</span></code> a finite ordered set of variables, say <code class="docutils literal notranslate"><span class="pre">X1</span> <span class="pre">&lt;</span> <span class="pre">X2</span> <span class="pre">&lt;</span> <span class="pre">...</span> <span class="pre">&lt;</span> <span class="pre">Xn</span></code>. A set <code class="docutils literal notranslate"><span class="pre">S</span></code> of polynomials in <code class="docutils literal notranslate"><span class="pre">R[X1,</span> <span class="pre">X2,</span> <span class="pre">...,</span> <span class="pre">Xn]</span></code> is triangular if no elements of <code class="docutils literal notranslate"><span class="pre">S</span></code> lies in <code class="docutils literal notranslate"><span class="pre">R</span></code>, and if two distinct elements of <code class="docutils literal notranslate"><span class="pre">S</span></code> have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial <code class="docutils literal notranslate"><span class="pre">P</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> a non-constant polynomial <code class="docutils literal notranslate"><span class="pre">Q</span></code> if the degree of <code class="docutils literal notranslate"><span class="pre">P</span></code> in the main variable of <code class="docutils literal notranslate"><span class="pre">Q</span></code> is less than the main degree of <code class="docutils literal notranslate"><span class="pre">Q</span></code>. A polynomial <code class="docutils literal notranslate"><span class="pre">P</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> a triangular set <code class="docutils literal notranslate"><span class="pre">T</span></code> if it is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. every polynomial of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<dl class="simple">
<dt><a class="reference internal" href="Aggregate.html#id1"><span class="std std-ref">#</span></a>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="BasicType.html#id1"><span class="std std-ref">=</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="BasicType.html#l-basic-type"><span class="std std-ref">BasicType</span></a></p>
</dd>
<dt><a class="reference internal" href="BasicType.html#id2"><span class="std std-ref">~=</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="BasicType.html#l-basic-type"><span class="std std-ref">BasicType</span></a></p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-algebraic"></span><dl class="simple" id="index-1">
<dt><span class="spadfun">algebraic?</span>: (V, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">algebraic?(v,</span> <span class="pre">ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">v</span></code> is the main variable of some polynomial in <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-algebraic-variables"></span><dl class="simple" id="index-2">
<dt><span class="spadfun">algebraicVariables</span>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> V</dt><dd><p><code class="docutils literal notranslate"><span class="pre">algebraicVariables(ts)</span></code> returns the decreasingly sorted list of the main variables of the polynomials of <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-any"><span class="std std-ref">any?</span></a>: (P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-auto-reduced"></span><dl class="simple" id="index-3">
<dt><span class="spadfun">autoReduced?</span>: (%, (P, <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">autoReduced?(ts,</span> <span class="pre">redOp?)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff every element of <code class="docutils literal notranslate"><span class="pre">ts</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> to every other in the sense of <code class="docutils literal notranslate"><span class="pre">redOp?</span></code></p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-basic-set"></span><dl class="simple" id="index-4">
<dt><span class="spadfun">basicSet</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; Union(Record(bas: %, top: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P), failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">basicSet(ps,</span> <span class="pre">redOp?)</span></code> returns <code class="docutils literal notranslate"><span class="pre">[bs,</span> <span class="pre">ts]</span></code> where <code class="docutils literal notranslate"><span class="pre">concat(bs,</span> <span class="pre">ts)</span></code> is <code class="docutils literal notranslate"><span class="pre">ps</span></code> and <code class="docutils literal notranslate"><span class="pre">bs</span></code> is a basic set in Wu Wen Tsun sense of <code class="docutils literal notranslate"><span class="pre">ps</span></code> <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> the reduction-test <code class="docutils literal notranslate"><span class="pre">redOp?</span></code>, if no non-zero constant polynomial lie in <code class="docutils literal notranslate"><span class="pre">ps</span></code>, otherwise <code class="docutils literal notranslate"><span class="pre">&quot;failed&quot;</span></code> is returned.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><span class="spadfun">basicSet</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; Union(Record(bas: %, top: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P), failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">basicSet(ps,</span> <span class="pre">pred?,</span> <span class="pre">redOp?)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">basicSet(qs,</span> <span class="pre">redOp?)</span></code> where <code class="docutils literal notranslate"><span class="pre">qs</span></code> consists of the polynomials of <code class="docutils literal notranslate"><span class="pre">ps</span></code> satisfying property <code class="docutils literal notranslate"><span class="pre">pred?</span></code>.</p>
</dd>
<dt><a class="reference internal" href="CoercibleTo.html#l-coercible-to-coerce"><span class="std std-ref">coerce</span></a>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p>from <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span class="std std-ref">CoercibleTo</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</p>
</dd>
<dt><a class="reference internal" href="CoercibleTo.html#l-coercible-to-coerce"><span class="std std-ref">coerce</span></a>: % -&gt; <a class="reference internal" href="OutputForm.html#l-output-form"><span class="std std-ref">OutputForm</span></a></dt><dd><p>from <a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span class="std std-ref">CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l-output-form"><span class="std std-ref">OutputForm</span></a></p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-co-height"></span><dl class="simple" id="index-6">
<dt><span class="spadfun">coHeight</span>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a> if V has <a class="reference internal" href="Finite.html#l-finite"><span class="std std-ref">Finite</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">coHeight(ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">size()\$V</span></code> minus <code class="docutils literal notranslate"><span class="pre">\#ts</span></code>.</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-collect"><span class="std std-ref">collect</span></a>: (%, V) -&gt; %</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-collect-quasi-monic"></span><dl class="simple" id="index-7">
<dt><span class="spadfun">collectQuasiMonic</span>: % -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">collectQuasiMonic(ts)</span></code> returns the subset of <code class="docutils literal notranslate"><span class="pre">ts</span></code> consisting of the polynomials with initial in <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-collect-under"><span class="std std-ref">collectUnder</span></a>: (%, V) -&gt; %</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-collect-upper"><span class="std std-ref">collectUpper</span></a>: (%, V) -&gt; %</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-construct"><span class="std std-ref">construct</span></a>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P -&gt; %</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
<dt><a class="reference internal" href="ConvertibleTo.html#l-convertible-to-convert"><span class="std std-ref">convert</span></a>: % -&gt; <a class="reference internal" href="InputForm.html#l-input-form"><span class="std std-ref">InputForm</span></a></dt><dd><p>from <a class="reference internal" href="ConvertibleTo.html#l-convertible-to"><span class="std std-ref">ConvertibleTo</span></a> <a class="reference internal" href="InputForm.html#l-input-form"><span class="std std-ref">InputForm</span></a></p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-copy"><span class="std std-ref">copy</span></a>: % -&gt; %</dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-count"><span class="std std-ref">count</span></a>: (P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-count"><span class="std std-ref">count</span></a>: (P, %) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-degree"></span><dl class="simple" id="index-8">
<dt><span class="spadfun">degree</span>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">degree(ts)</span></code> returns the product of main degrees of the members of <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-empty"><span class="std std-ref">empty</span></a>: () -&gt; %</dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#id2"><span class="std std-ref">empty?</span></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-eq"><span class="std std-ref">eq?</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="Evalable.html#l-evalable-eval"><span class="std std-ref">eval</span></a>: (%, <a class="reference internal" href="Equation.html#l-equation"><span class="std std-ref">Equation</span></a> P) -&gt; % if P has <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</dt><dd><p>from <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Evalable.html#l-evalable-eval"><span class="std std-ref">eval</span></a>: (%, <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Equation.html#l-equation"><span class="std std-ref">Equation</span></a> P) -&gt; % if P has <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</dt><dd><p>from <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</p>
</dd>
<dt><a class="reference internal" href="InnerEvalable.html#l-inner-evalable-eval"><span class="std std-ref">eval</span></a>: (%, <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P) -&gt; % if P has <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</dt><dd><p>from <a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><span class="std std-ref">InnerEvalable</span></a>(P, P)</p>
</dd>
<dt><a class="reference internal" href="InnerEvalable.html#l-inner-evalable-eval"><span class="std std-ref">eval</span></a>: (%, P, P) -&gt; % if P has <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</dt><dd><p>from <a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><span class="std std-ref">InnerEvalable</span></a>(P, P)</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-every"><span class="std std-ref">every?</span></a>: (P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-extend"></span><dl class="simple" id="index-9">
<dt><span class="spadfun">extend</span>: (%, P) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">extend(ts,</span> <span class="pre">p)</span></code> returns a triangular set which encodes the simple extension by <code class="docutils literal notranslate"><span class="pre">p</span></code> of the extension of the base field defined by <code class="docutils literal notranslate"><span class="pre">ts</span></code>, according to the properties of triangular sets of the current category If the required properties do not hold an error is returned.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-extend-if-can"></span><dl class="simple" id="index-10">
<dt><span class="spadfun">extendIfCan</span>: (%, P) -&gt; Union(%, failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">extendIfCan(ts,</span> <span class="pre">p)</span></code> returns a triangular set which encodes the simple extension by <code class="docutils literal notranslate"><span class="pre">p</span></code> of the extension of the base field defined by <code class="docutils literal notranslate"><span class="pre">ts</span></code>, according to the properties of triangular sets of the current domain. If the required properties do not hold then “failed” is returned. This operation encodes in some sense the properties of the triangular sets of the current category. Is is used to implement the <code class="docutils literal notranslate"><span class="pre">construct</span></code> operation to guarantee that every triangular set build from a list of polynomials has the required properties.</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-find"><span class="std std-ref">find</span></a>: (P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; Union(P, failed)</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-first"></span><dl class="simple" id="index-11">
<dt><span class="spadfun">first</span>: % -&gt; Union(P, failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">first(ts)</span></code> returns the polynomial of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with greatest main variable if <code class="docutils literal notranslate"><span class="pre">ts</span></code> is not empty, otherwise returns <code class="docutils literal notranslate"><span class="pre">&quot;failed&quot;</span></code>.</p>
</dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-hash"><span class="std std-ref">hash</span></a>: % -&gt; <a class="reference internal" href="SingleInteger.html#l-single-integer"><span class="std std-ref">SingleInteger</span></a></dt><dd><p>from <a class="reference internal" href="SetCategory.html#l-set-category"><span class="std std-ref">SetCategory</span></a></p>
</dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-hash-update"><span class="std std-ref">hashUpdate!</span></a>: (<a class="reference internal" href="HashState.html#l-hash-state"><span class="std std-ref">HashState</span></a>, %) -&gt; <a class="reference internal" href="HashState.html#l-hash-state"><span class="std std-ref">HashState</span></a></dt><dd><p>from <a class="reference internal" href="SetCategory.html#l-set-category"><span class="std std-ref">SetCategory</span></a></p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-head-reduce"></span><dl class="simple" id="index-12">
<dt><span class="spadfun">headReduce</span>: (P, %) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">headReduce(p,</span> <span class="pre">ts)</span></code> returns a polynomial <code class="docutils literal notranslate"><span class="pre">r</span></code> such that <code class="docutils literal notranslate"><span class="pre">headReduce?(r,</span> <span class="pre">ts)</span></code> holds and there exists some product <code class="docutils literal notranslate"><span class="pre">h</span></code> of <code class="docutils literal notranslate"><span class="pre">initials(ts)</span></code> such that <code class="docutils literal notranslate"><span class="pre">h*p</span> <span class="pre">-</span> <span class="pre">r</span></code> lies in the ideal generated by <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-head-reduced"></span><dl class="simple" id="index-13">
<dt><span class="spadfun">headReduced?</span>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">headReduced?(ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff the head of every element of <code class="docutils literal notranslate"><span class="pre">ts</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> to any other element of <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><span class="spadfun">headReduced?</span>: (P, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">headReduced?(p,</span> <span class="pre">ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff the head of <code class="docutils literal notranslate"><span class="pre">p</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-head-remainder"><span class="std std-ref">headRemainder</span></a>: (P, %) -&gt; Record(num: P, den: R)</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-iexact-quo"><span class="std std-ref">iexactQuo</span></a>: (R, R) -&gt; R</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-inf-ritt-wu"></span><dl class="simple" id="index-15">
<dt><span class="spadfun">infRittWu?</span>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">infRittWu?(ts1,</span> <span class="pre">ts2)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">ts2</span></code> has higher rank than <code class="docutils literal notranslate"><span class="pre">ts1</span></code> in Wu Wen Tsun sense.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-initially-reduce"></span><dl class="simple" id="index-16">
<dt><span class="spadfun">initiallyReduce</span>: (P, %) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">initiallyReduce(p,</span> <span class="pre">ts)</span></code> returns a polynomial <code class="docutils literal notranslate"><span class="pre">r</span></code> such that <code class="docutils literal notranslate"><span class="pre">initiallyReduced?(r,</span> <span class="pre">ts)</span></code> holds and there exists some product <code class="docutils literal notranslate"><span class="pre">h</span></code> of <code class="docutils literal notranslate"><span class="pre">initials(ts)</span></code> such that <code class="docutils literal notranslate"><span class="pre">h*p</span> <span class="pre">-</span> <span class="pre">r</span></code> lies in the ideal generated by <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-initially-reduced"></span><dl class="simple" id="index-17">
<dt><span class="spadfun">initiallyReduced?</span>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">initiallyReduced?(ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff for every element <code class="docutils literal notranslate"><span class="pre">p</span></code> of <code class="docutils literal notranslate"><span class="pre">ts</span></code> <code class="docutils literal notranslate"><span class="pre">p</span></code> and all its iterated initials are reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. to the other elements of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with the same main variable.</p>
</dd>
</dl>
<dl class="simple" id="index-18">
<dt><span class="spadfun">initiallyReduced?</span>: (P, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">initiallyReduced?(p,</span> <span class="pre">ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> and all its iterated initials are reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. to the elements of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with the same main variable.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-initials"></span><dl class="simple" id="index-19">
<dt><span class="spadfun">initials</span>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">initials(ts)</span></code> returns the list of the non-constant initials of the members of <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-last"></span><dl class="simple" id="index-20">
<dt><span class="spadfun">last</span>: % -&gt; Union(P, failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">last(ts)</span></code> returns the polynomial of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with smallest main variable if <code class="docutils literal notranslate"><span class="pre">ts</span></code> is not empty, otherwise returns <code class="docutils literal notranslate"><span class="pre">&quot;failed&quot;</span></code>.</p>
</dd>
<dt><a class="reference internal" href="SetCategory.html#l-set-category-latex"><span class="std std-ref">latex</span></a>: % -&gt; <a class="reference internal" href="String.html#l-string"><span class="std std-ref">String</span></a></dt><dd><p>from <a class="reference internal" href="SetCategory.html#l-set-category"><span class="std std-ref">SetCategory</span></a></p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-less"><span class="std std-ref">less?</span></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-main-variable"><span class="std std-ref">mainVariable?</span></a>: (V, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-main-variables"><span class="std std-ref">mainVariables</span></a>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> V</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-map"><span class="std std-ref">map!</span></a>: (P -&gt; P, %) -&gt; %</dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#id1"><span class="std std-ref">map</span></a>: (P -&gt; P, %) -&gt; %</dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-max"><span class="std std-ref">max</span></a>: % -&gt; P if P has <a class="reference internal" href="OrderedSet.html#l-ordered-set"><span class="std std-ref">OrderedSet</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-max"><span class="std std-ref">max</span></a>: ((P, P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; P</dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-member"><span class="std std-ref">member?</span></a>: (P, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-members"><span class="std std-ref">members</span></a>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-min"><span class="std std-ref">min</span></a>: % -&gt; P if P has <a class="reference internal" href="OrderedSet.html#l-ordered-set"><span class="std std-ref">OrderedSet</span></a></dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-more"><span class="std std-ref">more?</span></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-mvar"><span class="std std-ref">mvar</span></a>: % -&gt; V</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-normalized"></span><dl class="simple" id="index-21">
<dt><span class="spadfun">normalized?</span>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">normalized?(ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff for every <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">ts</span></code> we have <code class="docutils literal notranslate"><span class="pre">normalized?(p,</span> <span class="pre">us)</span></code> where <code class="docutils literal notranslate"><span class="pre">us</span></code> is <code class="docutils literal notranslate"><span class="pre">collectUnder(ts,</span> <span class="pre">mvar(p))</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-22">
<dt><span class="spadfun">normalized?</span>: (P, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">normalized?(p,</span> <span class="pre">ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> and all its iterated initials have degree zero <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. the main variables of the polynomials of <code class="docutils literal notranslate"><span class="pre">ts</span></code></p>
</dd>
<dt><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate-parts"><span class="std std-ref">parts</span></a>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p>from <a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-quasi-component"></span><dl class="simple" id="index-23">
<dt><span class="spadfun">quasiComponent</span>: % -&gt; Record(close: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, open: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">quasiComponent(ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">[lp,</span> <span class="pre">lq]</span></code> where <code class="docutils literal notranslate"><span class="pre">lp</span></code> is the list of the members of <code class="docutils literal notranslate"><span class="pre">ts</span></code> and <code class="docutils literal notranslate"><span class="pre">lq</span></code>is <code class="docutils literal notranslate"><span class="pre">initials(ts)</span></code>.</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-reduce"><span class="std std-ref">reduce</span></a>: ((P, P) -&gt; P, %) -&gt; P</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-reduce"><span class="std std-ref">reduce</span></a>: ((P, P) -&gt; P, %, P) -&gt; P</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-reduce"><span class="std std-ref">reduce</span></a>: ((P, P) -&gt; P, %, P, P) -&gt; P</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-reduce"></span><dl class="simple" id="index-24">
<dt><span class="spadfun">reduce</span>: (P, %, (P, P) -&gt; P, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">reduce(p,</span> <span class="pre">ts,</span> <span class="pre">redOp,</span> <span class="pre">redOp?)</span></code> returns a polynomial <code class="docutils literal notranslate"><span class="pre">r</span></code> such that <code class="docutils literal notranslate"><span class="pre">redOp?(r,</span> <span class="pre">p)</span></code> holds for every <code class="docutils literal notranslate"><span class="pre">p</span></code> of <code class="docutils literal notranslate"><span class="pre">ts</span></code> and there exists some product <code class="docutils literal notranslate"><span class="pre">h</span></code> of the initials of the members of <code class="docutils literal notranslate"><span class="pre">ts</span></code> such that <code class="docutils literal notranslate"><span class="pre">h*p</span> <span class="pre">-</span> <span class="pre">r</span></code> lies in the ideal generated by <code class="docutils literal notranslate"><span class="pre">ts</span></code>. The operation <code class="docutils literal notranslate"><span class="pre">redOp</span></code> must satisfy the following conditions. For every <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> we have <code class="docutils literal notranslate"><span class="pre">redOp?(redOp(p,</span> <span class="pre">q),</span> <span class="pre">q)</span></code> and there exists an integer <code class="docutils literal notranslate"><span class="pre">e</span></code> and a polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> such that <code class="docutils literal notranslate"><span class="pre">init(q)^e*p</span> <span class="pre">=</span> <span class="pre">f*q</span> <span class="pre">+</span> <span class="pre">redOp(p,</span> <span class="pre">q)</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-reduce-by-quasi-monic"></span><dl class="simple" id="index-25">
<dt><span class="spadfun">reduceByQuasiMonic</span>: (P, %) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">reduceByQuasiMonic(p,</span> <span class="pre">ts)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">remainder(p,</span> <span class="pre">collectQuasiMonic(ts)).polnum</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-reduced"></span><dl class="simple" id="index-26">
<dt><span class="spadfun">reduced?</span>: (P, %, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">reduced?(p,</span> <span class="pre">ts,</span> <span class="pre">redOp?)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. in the sense of the operation <code class="docutils literal notranslate"><span class="pre">redOp?</span></code>, that is if for every <code class="docutils literal notranslate"><span class="pre">t</span></code> in <code class="docutils literal notranslate"><span class="pre">ts</span></code> <code class="docutils literal notranslate"><span class="pre">redOp?(p,</span> <span class="pre">t)</span></code> holds.</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-remainder"><span class="std std-ref">remainder</span></a>: (P, %) -&gt; Record(rnum: R, polnum: P, den: R)</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-remove"><span class="std std-ref">remove</span></a>: (P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; %</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-remove"><span class="std std-ref">remove</span></a>: (P, %) -&gt; %</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-remove-duplicates"><span class="std std-ref">removeDuplicates</span></a>: % -&gt; %</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-remove-zero"></span><dl class="simple" id="index-27">
<dt><span class="spadfun">removeZero</span>: (P, %) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">removeZero(p,</span> <span class="pre">ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">p</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">0</span></code> by pseudo-division <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> <code class="docutils literal notranslate"><span class="pre">ts</span></code> otherwise returns a polynomial <code class="docutils literal notranslate"><span class="pre">q</span></code> computed from <code class="docutils literal notranslate"><span class="pre">p</span></code> by removing any coefficient in <code class="docutils literal notranslate"><span class="pre">p</span></code> reducing to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-rest"></span><dl class="simple" id="index-28">
<dt><span class="spadfun">rest</span>: % -&gt; Union(%, failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rest(ts)</span></code> returns the polynomials of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with smaller main variable than <code class="docutils literal notranslate"><span class="pre">mvar(ts)</span></code> if <code class="docutils literal notranslate"><span class="pre">ts</span></code> is not empty, otherwise returns “failed”</p>
</dd>
<dt><a class="reference internal" href="RetractableFrom.html#l-retractable-from-retract"><span class="std std-ref">retract</span></a>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P -&gt; %</dt><dd><p>from <a class="reference internal" href="RetractableFrom.html#l-retractable-from"><span class="std std-ref">RetractableFrom</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</p>
</dd>
<dt><a class="reference internal" href="RetractableFrom.html#l-retractable-from-retract-if-can"><span class="std std-ref">retractIfCan</span></a>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P -&gt; Union(%, failed)</dt><dd><p>from <a class="reference internal" href="RetractableFrom.html#l-retractable-from"><span class="std std-ref">RetractableFrom</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-rewrite-ideal-with-head-remainder"><span class="std std-ref">rewriteIdealWithHeadRemainder</span></a>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, %) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-rewrite-ideal-with-remainder"><span class="std std-ref">rewriteIdealWithRemainder</span></a>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, %) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-rewrite-set-with-reduction"></span><dl class="simple" id="index-29">
<dt><span class="spadfun">rewriteSetWithReduction</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P, %, (P, P) -&gt; P, (P, P) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rewriteSetWithReduction(lp,</span> <span class="pre">ts,</span> <span class="pre">redOp,</span> <span class="pre">redOp?)</span></code> returns a list <code class="docutils literal notranslate"><span class="pre">lq</span></code> of polynomials such that <code class="docutils literal notranslate"><span class="pre">[reduce(p,</span> <span class="pre">ts,</span> <span class="pre">redOp,</span> <span class="pre">redOp?)</span> <span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">lp]</span></code> and <code class="docutils literal notranslate"><span class="pre">lp</span></code> have the same zeros inside the regular zero set of <code class="docutils literal notranslate"><span class="pre">ts</span></code>. Moreover, for every polynomial <code class="docutils literal notranslate"><span class="pre">q</span></code> in <code class="docutils literal notranslate"><span class="pre">lq</span></code> and every polynomial <code class="docutils literal notranslate"><span class="pre">t</span></code> in <code class="docutils literal notranslate"><span class="pre">ts</span></code> <code class="docutils literal notranslate"><span class="pre">redOp?(q,</span> <span class="pre">t)</span></code> holds and there exists a polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> in the ideal generated by <code class="docutils literal notranslate"><span class="pre">lp</span></code> and a product <code class="docutils literal notranslate"><span class="pre">h</span></code> of <code class="docutils literal notranslate"><span class="pre">initials(ts)</span></code> such that <code class="docutils literal notranslate"><span class="pre">h*p</span> <span class="pre">-</span> <span class="pre">r</span></code> lies in the ideal generated by <code class="docutils literal notranslate"><span class="pre">ts</span></code>. The operation <code class="docutils literal notranslate"><span class="pre">redOp</span></code> must satisfy the following conditions. For every <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> we have <code class="docutils literal notranslate"><span class="pre">redOp?(redOp(p,</span> <span class="pre">q),</span> <span class="pre">q)</span></code> and there exists an integer <code class="docutils literal notranslate"><span class="pre">e</span></code> and a polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> such that <code class="docutils literal notranslate"><span class="pre">init(q)^e*p</span> <span class="pre">=</span> <span class="pre">f*q</span> <span class="pre">+</span> <span class="pre">redOp(p,</span> <span class="pre">q)</span></code>.</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-rough-base"><span class="std std-ref">roughBase?</span></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-rough-equal-ideals"><span class="std std-ref">roughEqualIdeals?</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-rough-sub-ideal"><span class="std std-ref">roughSubIdeal?</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-rough-unit-ideal"><span class="std std-ref">roughUnitIdeal?</span></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-sample"><span class="std std-ref">sample</span></a>: %</dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-select"></span><dl class="simple" id="index-30">
<dt><span class="spadfun">select</span>: (%, V) -&gt; Union(P, failed)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">select(ts,</span> <span class="pre">v)</span></code> returns the polynomial of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with <code class="docutils literal notranslate"><span class="pre">v</span></code> as main variable, if any.</p>
</dd>
<dt><a class="reference internal" href="Collection.html#l-collection-select"><span class="std std-ref">select</span></a>: (P -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, %) -&gt; %</dt><dd><p>from <a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
</dd>
<dt><a class="reference internal" href="Aggregate.html#l-aggregate-size"><span class="std std-ref">size?</span></a>: (%, <a class="reference internal" href="NonNegativeInteger.html#l-non-negative-integer"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-sort"><span class="std std-ref">sort</span></a>: (%, V) -&gt; Record(under: %, floor: %, upper: %)</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-strongly-reduce"></span><dl class="simple" id="index-31">
<dt><span class="spadfun">stronglyReduce</span>: (P, %) -&gt; P</dt><dd><p><code class="docutils literal notranslate"><span class="pre">stronglyReduce(p,</span> <span class="pre">ts)</span></code> returns a polynomial <code class="docutils literal notranslate"><span class="pre">r</span></code> such that <code class="docutils literal notranslate"><span class="pre">stronglyReduced?(r,</span> <span class="pre">ts)</span></code> holds and there exists some product <code class="docutils literal notranslate"><span class="pre">h</span></code> of <code class="docutils literal notranslate"><span class="pre">initials(ts)</span></code> such that <code class="docutils literal notranslate"><span class="pre">h*p</span> <span class="pre">-</span> <span class="pre">r</span></code> lies in the ideal generated by <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-strongly-reduced"></span><dl class="simple" id="index-32">
<dt><span class="spadfun">stronglyReduced?</span>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">stronglyReduced?(ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff every element of <code class="docutils literal notranslate"><span class="pre">ts</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code> to any other element of <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-33">
<dt><span class="spadfun">stronglyReduced?</span>: (P, %) -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">stronglyReduced?(p,</span> <span class="pre">ts)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> iff <code class="docutils literal notranslate"><span class="pre">p</span></code> is reduced <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. <code class="docutils literal notranslate"><span class="pre">ts</span></code>.</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-triangular"><span class="std std-ref">triangular?</span></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-trivial-ideal"><span class="std std-ref">trivialIdeal?</span></a>: % -&gt; <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
<dt><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category-variables"><span class="std std-ref">variables</span></a>: % -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> V</dt><dd><p>from <a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-zero-set-split"></span><dl class="simple" id="index-34">
<dt><span class="spadfun">zeroSetSplit</span>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">zeroSetSplit(lp)</span></code> returns a list <code class="docutils literal notranslate"><span class="pre">lts</span></code> of triangular sets such that the zero set of <code class="docutils literal notranslate"><span class="pre">lp</span></code> is the union of the closures of the regular zero sets of the members of <code class="docutils literal notranslate"><span class="pre">lts</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-triangular-set-category-zero-set-split-into-triangular-systems"></span><dl class="simple" id="index-35">
<dt><span class="spadfun">zeroSetSplitIntoTriangularSystems</span>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> Record(close: %, open: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">zeroSetSplitIntoTriangularSystems(lp)</span></code> returns a list of triangular systems <code class="docutils literal notranslate"><span class="pre">[[ts1,</span> <span class="pre">qs1],</span> <span class="pre">...,</span> <span class="pre">[tsn,</span> <span class="pre">qsn]]</span></code> such that the zero set of <code class="docutils literal notranslate"><span class="pre">lp</span></code> is the union of the closures of the <code class="docutils literal notranslate"><span class="pre">W_i</span></code> where <code class="docutils literal notranslate"><span class="pre">W_i</span></code> consists of the zeros of <code class="docutils literal notranslate"><span class="pre">ts</span></code> which do not cancel any polynomial in <code class="docutils literal notranslate"><span class="pre">qsi</span></code>.</p>
</dd>
</dl>
<p><a class="reference internal" href="Aggregate.html#l-aggregate"><span class="std std-ref">Aggregate</span></a></p>
<p><a class="reference internal" href="BasicType.html#l-basic-type"><span class="std std-ref">BasicType</span></a></p>
<p><a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span class="std std-ref">CoercibleTo</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</p>
<p><a class="reference internal" href="CoercibleTo.html#l-coercible-to"><span class="std std-ref">CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l-output-form"><span class="std std-ref">OutputForm</span></a></p>
<p><a class="reference internal" href="Collection.html#l-collection"><span class="std std-ref">Collection</span></a> P</p>
<p><a class="reference internal" href="ConvertibleTo.html#l-convertible-to"><span class="std std-ref">ConvertibleTo</span></a> <a class="reference internal" href="InputForm.html#l-input-form"><span class="std std-ref">InputForm</span></a></p>
<p><a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P if P has <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</p>
<p><a class="reference internal" href="finiteAggregate.html#l-finite-aggregate"><span class="std std-ref">finiteAggregate</span></a></p>
<p><a class="reference internal" href="HomogeneousAggregate.html#l-homogeneous-aggregate"><span class="std std-ref">HomogeneousAggregate</span></a> P</p>
<p><a class="reference internal" href="InnerEvalable.html#l-inner-evalable"><span class="std std-ref">InnerEvalable</span></a>(P, P) if P has <a class="reference internal" href="Evalable.html#l-evalable"><span class="std std-ref">Evalable</span></a> P</p>
<p><a class="reference internal" href="PolynomialSetCategory.html#l-polynomial-set-category"><span class="std std-ref">PolynomialSetCategory</span></a>(R, E, V, P)</p>
<p><a class="reference internal" href="RetractableFrom.html#l-retractable-from"><span class="std std-ref">RetractableFrom</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> P</p>
<p><a class="reference internal" href="SetCategory.html#l-set-category"><span class="std std-ref">SetCategory</span></a></p>
<p><a class="reference internal" href="shallowlyMutable.html#l-shallowly-mutable"><span class="std std-ref">shallowlyMutable</span></a></p>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FriCAS API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="TrigonometricFunctionCategory.html" title="TrigonometricFunctionCategory"
             >next</a> |</li>
        <li class="right" >
          <a href="TranscendentalFunctionCategory.html" title="TranscendentalFunctionCategory"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS dc27d6f8d24fbb7a59b9b1c208e5ea960b3943d8</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Categories.html" >Categories</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">TriangularSetCategory(R, E, V, P)</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2020, FriCAS Team.
    </div>
  </body>
</html>