
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZeroDimensionalSolvePackage(R, ls, ls2) &#8212; FriCAS dc27d6f8d24fbb7a59b9b1c208e5ea960b3943d8</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Features" href="../features.html" />
    <link rel="prev" title="XPolynomialFactor(vl, F)" href="XPolynomialFactor.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../features.html" title="Features"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="XPolynomialFactor.html" title="XPolynomialFactor(vl, F)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS dc27d6f8d24fbb7a59b9b1c208e5ea960b3943d8</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Packages.html" accesskey="U">Packages</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ZeroDimensionalSolvePackage(R, ls, ls2)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="zerodimensionalsolvepackage-r-ls-ls2">
<span id="l-zero-dimensional-solve-package"></span><span id="index-0"></span><h1>ZeroDimensionalSolvePackage(R, ls, ls2)<a class="headerlink" href="#zerodimensionalsolvepackage-r-ls-ls2" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://github.com/hemmecke/fricas/blob/formatted/src/algebra/zerodim.spad#L647">zerodim.spad line 647</a> <a class="reference external" href="https://github.com/hemmecke/fricas/edit/formatted/src/algebra/zerodim.spad#L647">[edit on github]</a></p>
<ul class="simple">
<li><p>R: Join(<a class="reference internal" href="OrderedRing.html#l-ordered-ring"><span class="std std-ref">OrderedRing</span></a>, <a class="reference internal" href="PolynomialFactorizationExplicit.html#l-polynomial-factorization-explicit"><span class="std std-ref">PolynomialFactorizationExplicit</span></a>, <a class="reference internal" href="CharacteristicZero.html#l-characteristic-zero"><span class="std std-ref">CharacteristicZero</span></a>, <a class="reference internal" href="RealConstant.html#l-real-constant"><span class="std std-ref">RealConstant</span></a>)</p></li>
<li><p>ls: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Symbol.html#l-symbol"><span class="std std-ref">Symbol</span></a></p></li>
<li><p>ls2: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Symbol.html#l-symbol"><span class="std std-ref">Symbol</span></a></p></li>
</ul>
<p>A package for computing symbolically the complex and real roots of zero-dimensional algebraic systems over the integer or rational numbers. Complex roots are given by means of univariate representations of irreducible regular chains. Real roots are given by means of tuples of coordinates lying in the <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> of the coefficient ring. This constructor takes three arguments. The first one <code class="docutils literal notranslate"><span class="pre">R</span></code> is the coefficient ring. The second one <code class="docutils literal notranslate"><span class="pre">ls</span></code> is the list of variables involved in the systems to solve. The third one must be <code class="docutils literal notranslate"><span class="pre">concat(ls,</span> <span class="pre">s)</span></code> where <code class="docutils literal notranslate"><span class="pre">s</span></code> is an additional symbol used for the univariate representations. WARNING: The third argument is not checked. All operations are based on triangular decompositions. The default is to compute these decompositions directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a> domain constructor. The lexTriangular algorithm can also be used for computing these decompositions (see the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><span class="std std-ref">LexTriangularPackage</span></a> package constructor). For that purpose, the operations <a class="reference internal" href="#l-zero-dimensional-solve-package-univariate-solve"><span class="std std-ref">univariateSolve</span></a>, <a class="reference internal" href="#l-zero-dimensional-solve-package-real-solve"><span class="std std-ref">realSolve</span></a> and <a class="reference internal" href="#l-zero-dimensional-solve-package-positive-solve"><span class="std std-ref">positiveSolve</span></a> admit an optional argument.   Author: Marc Moreno Maza.</p>
<span class="target" id="l-zero-dimensional-solve-package-convert"></span><dl class="simple" id="index-1">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><span class="std std-ref">NewSparseMultivariatePolynomial</span></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls) -&gt; <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><span class="std std-ref">NewSparseMultivariatePolynomial</span></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">convert(q)</span></code> converts <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><span class="std std-ref">NewSparseMultivariatePolynomial</span></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2) -&gt; <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">convert(q)</span></code> converts <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R -&gt; <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">convert(p)</span></code> converts <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> R -&gt; <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">convert(u)</span></code> converts <code class="docutils literal notranslate"><span class="pre">u</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><span class="spadfun">convert</span>: <a class="reference internal" href="SquareFreeRegularTriangularSet.html#l-square-free-regular-triangular-set"><span class="std std-ref">SquareFreeRegularTriangularSet</span></a>(R, <a class="reference internal" href="IndexedExponents.html#l-indexed-exponents"><span class="std std-ref">IndexedExponents</span></a> <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2, <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><span class="std std-ref">NewSparseMultivariatePolynomial</span></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2)) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><span class="std std-ref">NewSparseMultivariatePolynomial</span></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">convert(st)</span></code> returns the members of <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-positive-solve"></span><dl class="simple" id="index-6">
<dt><span class="spadfun">positiveSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">positiveSolve(lp)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">positiveSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-7">
<dt><span class="spadfun">positiveSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">positiveSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">lextri?)</span></code> returns the set of the points in the variety associated with <code class="docutils literal notranslate"><span class="pre">lp</span></code> whose coordinates are (real) strictly positive. Moreover, if <code class="docutils literal notranslate"><span class="pre">info?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then some information is displayed during decomposition into regular chains. If <code class="docutils literal notranslate"><span class="pre">lextri?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><span class="std std-ref">LexTriangularPackage</span></a> constructor (see <span class="xref std std-ref">zeroSetSplit &lt;l–lex-triangular-package_zero-set-split&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">false</span></code>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><span class="std std-ref">zeroSetSplit</span></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>. WARNING: For each set of coordinates given by <code class="docutils literal notranslate"><span class="pre">positiveSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">lextri?)</span></code> the ordering of the indeterminates is reversed <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. <code class="docutils literal notranslate"><span class="pre">ls</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-8">
<dt><span class="spadfun">positiveSolve</span>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">positiveSolve(lp)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">positiveSolve(lp,</span> <span class="pre">false,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-9">
<dt><span class="spadfun">positiveSolve</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">positiveSolve(ts)</span></code> returns the points of the regular set of <code class="docutils literal notranslate"><span class="pre">ts</span></code> with (real) strictly positive coordinates.</p>
</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-real-solve"></span><dl class="simple" id="index-10">
<dt><span class="spadfun">realSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">info?)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">false,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-11">
<dt><span class="spadfun">realSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-12">
<dt><span class="spadfun">realSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">lextri?)</span></code> returns the set of the points in the variety associated with <code class="docutils literal notranslate"><span class="pre">lp</span></code> whose coordinates are all real. Moreover, if <code class="docutils literal notranslate"><span class="pre">info?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then some information is displayed during decomposition into regular chains. If <code class="docutils literal notranslate"><span class="pre">check?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then the result is checked. If <code class="docutils literal notranslate"><span class="pre">lextri?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><span class="std std-ref">LexTriangularPackage</span></a> constructor (see <span class="xref std std-ref">zeroSetSplit &lt;l–lex-triangular-package_zero-set-split&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">false</span></code>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><span class="std std-ref">zeroSetSplit</span></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>. WARNING: For each set of coordinates given by <code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">lextri?)</span></code> the ordering of the indeterminates is reversed <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. <code class="docutils literal notranslate"><span class="pre">ls</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-13">
<dt><span class="spadfun">realSolve</span>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">realSolve(lp)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">realSolve(ts,</span> <span class="pre">false,</span> <span class="pre">false,</span> <span class="pre">false)</span></code></p>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><span class="spadfun">realSolve</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RealClosure.html#l-real-closure"><span class="std std-ref">RealClosure</span></a> <a class="reference internal" href="Fraction.html#l-fraction"><span class="std std-ref">Fraction</span></a> R</dt><dd><p><code class="docutils literal notranslate"><span class="pre">realSolve(ts)</span></code> returns the set of the points in the regular zero set of <code class="docutils literal notranslate"><span class="pre">ts</span></code> whose coordinates are all real. WARNING: For each set of coordinates given by <code class="docutils literal notranslate"><span class="pre">realSolve(ts)</span></code> the ordering of the indeterminates is reversed <code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. <code class="docutils literal notranslate"><span class="pre">ls</span></code>.</p>
</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-square-free"></span><dl class="simple" id="index-15">
<dt><span class="spadfun">squareFree</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="SquareFreeRegularTriangularSet.html#l-square-free-regular-triangular-set"><span class="std std-ref">SquareFreeRegularTriangularSet</span></a>(R, <a class="reference internal" href="IndexedExponents.html#l-indexed-exponents"><span class="std std-ref">IndexedExponents</span></a> <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2, <a class="reference internal" href="NewSparseMultivariatePolynomial.html#l-new-sparse-multivariate-polynomial"><span class="std std-ref">NewSparseMultivariatePolynomial</span></a>(R, <a class="reference internal" href="OrderedVariableList.html#l-ordered-variable-list"><span class="std std-ref">OrderedVariableList</span></a> ls2))</dt><dd><p><code class="docutils literal notranslate"><span class="pre">squareFree(ts)</span></code> returns the square-free factorization of <code class="docutils literal notranslate"><span class="pre">ts</span></code>. Moreover, each factor is a Lazard triangular set and the decomposition is a Kalkbrener split of <code class="docutils literal notranslate"><span class="pre">ts</span></code>, which is enough here for the matter of solving zero-dimensional algebraic systems. WARNING: <code class="docutils literal notranslate"><span class="pre">ts</span></code> is not checked to be zero-dimensional.</p>
</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-triang-solve"></span><dl class="simple" id="index-16">
<dt><span class="spadfun">triangSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">triangSolve(lp,</span> <span class="pre">info?)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">triangSolve(lp,</span> <span class="pre">false)</span></code></p>
</dd>
</dl>
<dl class="simple" id="index-17">
<dt><span class="spadfun">triangSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">triangSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">lextri?)</span></code> decomposes the variety associated with <code class="docutils literal notranslate"><span class="pre">lp</span></code> into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that <code class="docutils literal notranslate"><span class="pre">lp</span></code> needs to generate a zero-dimensional ideal. If <code class="docutils literal notranslate"><span class="pre">lp</span></code> is not zero-dimensional then the result is only a decomposition of its zero-set in the sense of the closure (<code class="docutils literal notranslate"><span class="pre">w</span></code>.<code class="docutils literal notranslate"><span class="pre">r</span></code>.<code class="docutils literal notranslate"><span class="pre">t</span></code>. Zarisky topology). Moreover, if <code class="docutils literal notranslate"><span class="pre">info?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then some information is displayed during the computations. See <span class="xref std std-ref">zeroSetSplit &lt;l–regular-triangular-set-category_zero-set-split&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">info?</span></code>). If <code class="docutils literal notranslate"><span class="pre">lextri?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><span class="std std-ref">LexTriangularPackage</span></a> constructor (see <span class="xref std std-ref">zeroSetSplit &lt;l–lex-triangular-package_zero-set-split&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">false</span></code>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><span class="std std-ref">zeroSetSplit</span></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>.</p>
</dd>
</dl>
<dl class="simple" id="index-18">
<dt><span class="spadfun">triangSolve</span>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">triangSolve(lp)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">triangSolve(lp,</span> <span class="pre">false,</span> <span class="pre">false)</span></code></p>
</dd>
</dl>
<span class="target" id="l-zero-dimensional-solve-package-univariate-solve"></span><dl class="simple" id="index-19">
<dt><span class="spadfun">univariateSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">false,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><span class="spadfun">univariateSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">check?)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><span class="spadfun">univariateSolve</span>: (<a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l-boolean"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariateSolve(lp,</span> <span class="pre">info?,</span> <span class="pre">check?,</span> <span class="pre">lextri?)</span></code> returns a univariate representation of the variety associated with <code class="docutils literal notranslate"><span class="pre">lp</span></code>. Moreover, if <code class="docutils literal notranslate"><span class="pre">info?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then some information is displayed during the decomposition into regular chains. If <code class="docutils literal notranslate"><span class="pre">check?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then the result is checked. See <span class="xref std std-ref">rur &lt;l–rational-univariate-representation-package_rur&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">true</span></code>). If <code class="docutils literal notranslate"><span class="pre">lextri?</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> then the lexTriangular algorithm is called from the <a class="reference internal" href="LexTriangularPackage.html#l-lex-triangular-package"><span class="std std-ref">LexTriangularPackage</span></a> constructor (see <span class="xref std std-ref">zeroSetSplit &lt;l–lex-triangular-package_zero-set-split&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">false</span></code>)). Otherwise, the triangular decomposition is computed directly from the input system by using the <a class="reference internal" href="RegularChain.html#l-regular-chain-zero-set-split"><span class="std std-ref">zeroSetSplit</span></a> from <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>.</p>
</dd>
</dl>
<dl class="simple" id="index-22">
<dt><span class="spadfun">univariateSolve</span>: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariateSolve(lp)</span></code> returns the same as <code class="docutils literal notranslate"><span class="pre">univariateSolve(lp,</span> <span class="pre">false,</span> <span class="pre">false,</span> <span class="pre">false)</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-23">
<dt><span class="spadfun">univariateSolve</span>: <a class="reference internal" href="RegularChain.html#l-regular-chain"><span class="std std-ref">RegularChain</span></a>(R, ls) -&gt; <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> Record(complexRoots: <a class="reference internal" href="SparseUnivariatePolynomial.html#l-sparse-univariate-polynomial"><span class="std std-ref">SparseUnivariatePolynomial</span></a> R, coordinates: <a class="reference internal" href="List.html#l-list"><span class="std std-ref">List</span></a> <a class="reference internal" href="Polynomial.html#l-polynomial"><span class="std std-ref">Polynomial</span></a> R)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">univariateSolve(ts)</span></code> returns a univariate representation of <code class="docutils literal notranslate"><span class="pre">ts</span></code>. See <span class="xref std std-ref">rur &lt;l–rational-univariate-representation-package_rur&gt;`(``lp`</span>, <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p>
</dd>
</dl>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FriCAS API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../features.html" title="Features"
             >next</a> |</li>
        <li class="right" >
          <a href="XPolynomialFactor.html" title="XPolynomialFactor(vl, F)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS dc27d6f8d24fbb7a59b9b1c208e5ea960b3943d8</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Packages.html" >Packages</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ZeroDimensionalSolvePackage(R, ls, ls2)</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2020, FriCAS Team.
    </div>
  </body>
</html>