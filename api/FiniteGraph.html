
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FiniteGraph S &#8212; FriCAS</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="FiniteGroup" href="FiniteGroup.html" />
    <link rel="prev" title="FiniteFieldCategory" href="FiniteFieldCategory.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="FiniteGroup.html" title="FiniteGroup"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="FiniteFieldCategory.html" title="FiniteFieldCategory"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Categories.html" accesskey="U">Categories</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">FiniteGraph S</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finitegraph-s">
<span id="l46696e6974654772617068"></span><span id="index-0"></span><h1>FiniteGraph S<a class="headerlink" href="#finitegraph-s" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://github.com/fricas/fricas/blob/master/src/algebra/graph.spad#L1113">graph.spad line 1113</a> <a class="reference external" href="https://github.com/fricas/fricas/edit/master/src/algebra/graph.spad#L1113">[edit on github]</a></p>
<ul class="simple">
<li><p>S: <a class="reference internal" href="SetCategory.html#l53657443617465676f7279"><span class="std std-ref">SetCategory</span></a></p></li>
</ul>
<p>Category of finite graphs, allows us to model graph theory</p>
<span class="target" id="l46696e6974654772617068-2b"></span><dl class="simple" id="index-1">
<dt><span class="spadfun">+</span>: (%, %) -&gt; %</dt><dd><p>sum : disjoint union of nodes with arrows from appropriate input</p>
</dd>
</dl>
<dl class="simple" id="l46696e6974654772617068-3d">
<dt><a class="reference internal" href="BasicType.html#l426173696354797065-3d"><span class="std std-ref">=</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="BasicType.html#l426173696354797065"><span class="std std-ref">BasicType</span></a></p>
</dd>
</dl>
<dl class="simple" id="l46696e6974654772617068-7e3d">
<dt><a class="reference internal" href="BasicType.html#l426173696354797065-7e3d"><span class="std std-ref">~=</span></a>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p>from <a class="reference internal" href="BasicType.html#l426173696354797065"><span class="std std-ref">BasicType</span></a></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6164644172726f7721"></span><dl class="simple" id="index-2">
<dt><span class="spadfun">addArrow!</span>: (%, Record(name: <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, arrType: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, fromOb: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, toOb: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, xOffset: <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>, yOffset: <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>, map: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>)) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">addArrow!(s,</span> <span class="pre">ar)</span></code> adds an arrow ar to the graph <code class="docutils literal notranslate"><span class="pre">s</span></code></p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><span class="spadfun">addArrow!</span>: (%, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">addArrow!(s,</span> <span class="pre">nm,</span> <span class="pre">n1,</span> <span class="pre">n2)</span></code> adds an arrow to the graph <code class="docutils literal notranslate"><span class="pre">s</span></code>, where: <code class="docutils literal notranslate"><span class="pre">nm</span></code> is the name of the arrow <code class="docutils literal notranslate"><span class="pre">n1</span></code> is the index of the start object <code class="docutils literal notranslate"><span class="pre">n2</span></code> is the index of the end object</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><span class="spadfun">addArrow!</span>: (%, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">addArrow!(s,</span> <span class="pre">nm,</span> <span class="pre">n1,</span> <span class="pre">n2,</span> <span class="pre">mp)</span></code> adds an arrow to the graph <code class="docutils literal notranslate"><span class="pre">s</span></code>, where: <code class="docutils literal notranslate"><span class="pre">nm</span></code> is the name of the arrow <code class="docutils literal notranslate"><span class="pre">n1</span></code> is the index of the start object <code class="docutils literal notranslate"><span class="pre">n2</span></code> is the index of the end object <code class="docutils literal notranslate"><span class="pre">mp</span></code> is a map represented by this arrow</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><span class="spadfun">addArrow!</span>: (%, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, S, S) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">addArrow!(s,</span> <span class="pre">nm,</span> <span class="pre">o1,</span> <span class="pre">o2)</span></code> adds an arrow to the graph <code class="docutils literal notranslate"><span class="pre">s</span></code>, where: <code class="docutils literal notranslate"><span class="pre">nm</span></code> is the name of the arrow <code class="docutils literal notranslate"><span class="pre">o1</span></code> is the start object <code class="docutils literal notranslate"><span class="pre">o2</span></code> is the end object</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6164644f626a65637421"></span><dl class="simple" id="index-6">
<dt><span class="spadfun">addObject!</span>: (%, Record(value: S, posX: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, posY: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>)) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">addObject!(s,</span> <span class="pre">n)</span></code> adds object with coordinates <code class="docutils literal notranslate"><span class="pre">n</span></code> to the graph <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-7">
<dt><span class="spadfun">addObject!</span>: (%, S) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">addObject!(s,</span> <span class="pre">n)</span></code> adds object <code class="docutils literal notranslate"><span class="pre">n</span></code> to the graph <code class="docutils literal notranslate"><span class="pre">s</span></code>. Use this version if you don<code class="docutils literal notranslate"><span class="pre">'t</span></code> intend to create diagrams and therefore don<code class="docutils literal notranslate"><span class="pre">'t</span></code> care about <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-61646a6163656e63794d6174726978"></span><dl class="simple" id="index-8">
<dt><span class="spadfun">adjacencyMatrix</span>: % -&gt; <a class="reference internal" href="Matrix.html#l4d6174726978"><span class="std std-ref">Matrix</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">adjacencyMatrix(s)</span></code> returns an <code class="docutils literal notranslate"><span class="pre">n</span></code> by <code class="docutils literal notranslate"><span class="pre">n</span></code> matrix A, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of vertices in the graph. If there is an edge from a vertex <code class="docutils literal notranslate"><span class="pre">x</span></code> to a vertex <code class="docutils literal notranslate"><span class="pre">y</span></code>, then the element ax, <code class="docutils literal notranslate"><span class="pre">y</span></code> is 1 (or in general the number of xy edges), otherwise it is 0. In computing, this matrix makes it easy to find subgraphs, and to reverse a directed graph.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6172726f774e616d65"></span><dl class="simple" id="index-9">
<dt><span class="spadfun">arrowName</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">arrowName(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> retrieves the name of arrow a-<code class="docutils literal notranslate"><span class="pre">&gt;b</span></code> if it does not exist then return <code class="docutils literal notranslate"><span class="pre">&quot;?&quot;</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6172726f777346726f6d4172726f77"></span><dl class="simple" id="index-10">
<dt><span class="spadfun">arrowsFromArrow</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p>index of all arrows leading to a given arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6172726f777346726f6d4e6f6465"></span><dl class="simple" id="index-11">
<dt><span class="spadfun">arrowsFromNode</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">arrowsFromNode(s,</span> <span class="pre">a)</span></code> gives list of all arrows leading to a given node</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6172726f7773546f4172726f77"></span><dl class="simple" id="index-12">
<dt><span class="spadfun">arrowsToArrow</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p>arrowsToArrow: (<code class="docutils literal notranslate"><span class="pre">s:</span></code> %, a: NNI) returns index of all arrows leading from a given arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6172726f7773546f4e6f6465"></span><dl class="simple" id="index-13">
<dt><span class="spadfun">arrowsToNode</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">arrowsToNode(s,</span> <span class="pre">a)</span></code> gives list of all arrows leading from a given node</p>
</dd>
</dl>
<dl class="simple" id="l46696e6974654772617068-636f65726365">
<dt><a class="reference internal" href="CoercibleTo.html#l436f65726369626c65546f-636f65726365"><span class="std std-ref">coerce</span></a>: % -&gt; <a class="reference internal" href="OutputForm.html#l4f7574707574466f726d"><span class="std std-ref">OutputForm</span></a></dt><dd><p>from <a class="reference internal" href="CoercibleTo.html#l436f65726369626c65546f"><span class="std std-ref">CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l4f7574707574466f726d"><span class="std std-ref">OutputForm</span></a></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6372656174655769647468"></span><dl class="simple" id="index-14">
<dt><span class="spadfun">createWidth</span>: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a> -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">createWidth(x)</span></code> can be used by domains which extend graph to help in creating coordinates for objects in a graph</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-63726561746558"></span><dl class="simple" id="index-15">
<dt><span class="spadfun">createX</span>: (<a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">createX(x,</span> <span class="pre">n)</span></code> can be used by domains which extend graph to help in creating the <code class="docutils literal notranslate"><span class="pre">x</span></code> coordinate for objects in a graph</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-63726561746559"></span><dl class="simple" id="index-16">
<dt><span class="spadfun">createY</span>: (<a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">createY(x,</span> <span class="pre">n)</span></code> can be used by domains which extend graph to help in creating the <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinate for objects in a graph</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6379636c65436c6f736564"></span><dl class="simple" id="index-17">
<dt><span class="spadfun">cycleClosed</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> S, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>) -&gt; %</dt><dd><p>cycleClosed: (objs: List <code class="docutils literal notranslate"><span class="pre">S</span></code>, arrowName: String) constructs a graph with vertices (from objs) connected in a cycle. arrowName is a prefix for all arrow names, this will be followed by a number starting at 1 and incremented for each arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6379636c654f70656e"></span><dl class="simple" id="index-18">
<dt><span class="spadfun">cycleOpen</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> S, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">cycleOpen(objs,</span> <span class="pre">arrowName)</span></code> constructs a graph with vertices (from <code class="docutils literal notranslate"><span class="pre">objs</span></code>) connected in a cycle but with one gap. The last vertex in the sequence loops back to itself so all vertices have one outgoing arrow. arrowName is a prefix for all arrow names, this will be followed by a number starting at 1 and incremented for each arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-646565704469616772616d537667"></span><p id="index-19"><span class="spadfun">deepDiagramSvg</span>: (<a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, %, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="Void.html#l566f6964"><span class="std std-ref">Void</span></a></p>
<span class="target" id="l46696e6974654772617068-6469616772616d486569676874"></span><dl class="simple" id="index-20">
<dt><span class="spadfun">diagramHeight</span>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">diagramHeight(s)</span></code> returns the height of the diagram that will be generated by diagramSvg. This is the maximum posY of all vertices in graph <code class="docutils literal notranslate"><span class="pre">s</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6469616772616d73537667"></span><dl class="simple" id="index-21">
<dt><span class="spadfun">diagramsSvg</span>: (<a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> %, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="Void.html#l566f6964"><span class="std std-ref">Void</span></a></dt><dd><p>creates <code class="docutils literal notranslate"><span class="pre">SVG</span></code> diagram containing multiple graphs fileName: String is the name of the <code class="docutils literal notranslate"><span class="pre">SVG</span></code> file that will be created <code class="docutils literal notranslate"><span class="pre">ln:</span></code> List % is list of graphs that will be written dispArrowName: Boolean is <code class="docutils literal notranslate"><span class="pre">true</span></code> to include the name of each arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6469616772616d537667"></span><dl class="simple" id="index-22">
<dt><span class="spadfun">diagramSvg</span>: (<a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, %, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="Void.html#l566f6964"><span class="std std-ref">Void</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">diagramSvg(fileName,</span> <span class="pre">n,</span> <span class="pre">dispArrowName)</span></code> creates an <code class="docutils literal notranslate"><span class="pre">SVG</span></code> diagram fileName: String is the name of the <code class="docutils literal notranslate"><span class="pre">SVG</span></code> file that will be created <code class="docutils literal notranslate"><span class="pre">n:</span></code> % is the graph that will be written dispArrowName: Boolean is <code class="docutils literal notranslate"><span class="pre">true</span></code> to include the name of each arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6469616772616d5769647468"></span><dl class="simple" id="index-23">
<dt><span class="spadfun">diagramWidth</span>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">diagramWidth(s)</span></code> returns the width of the diagram that will be generated by diagramSvg. This is the maximum posX of all vertices in graph <code class="docutils literal notranslate"><span class="pre">s</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-64697374616e6365"></span><dl class="simple" id="index-24">
<dt><span class="spadfun">distance</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">distance(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> gives the shortest distance between nodes ‘a’ and <code class="docutils literal notranslate"><span class="pre">'b'</span></code> as a number of hops. 0 if ‘a’ = <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, <code class="docutils literal notranslate"><span class="pre">-1</span></code> if it is not possible to go from ‘a’ to <code class="docutils literal notranslate"><span class="pre">'b'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-64697374616e63654d6174726978"></span><dl class="simple" id="index-25">
<dt><span class="spadfun">distanceMatrix</span>: % -&gt; <a class="reference internal" href="Matrix.html#l4d6174726978"><span class="std std-ref">Matrix</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">distanceMatrix(s)</span></code> gives matrix of distances between vertices. Element a_{<code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>} is the distance from <code class="docutils literal notranslate"><span class="pre">i</span></code> to <code class="docutils literal notranslate"><span class="pre">j</span></code>. Distance matrices are related to adjacency matrices, with the differences that: a. the latter only provides the information which vertices are connected but does not tell about costs or distances between the vertices <code class="docutils literal notranslate"><span class="pre">b</span></code>. adjacency matrix only tells us about directly connected vertices while distance matrix also considers indirect connections.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-666c617474656e"></span><dl class="simple" id="index-26">
<dt><span class="spadfun">flatten</span>: <a class="reference internal" href="DirectedGraph.html#l44697265637465644772617068"><span class="std std-ref">DirectedGraph</span></a> % -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">flatten(n)</span></code> takes a second order graph, that is a graph whose elements are themselves graphs and create a first order graph whose vertices are the vertices of the inner graphs.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6765744172726f77496e646578"></span><dl class="simple" id="index-27">
<dt><span class="spadfun">getArrowIndex</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">getArrowIndex(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> retrieves arrow index of the arrow form a to <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6765744172726f7773"></span><dl class="simple" id="index-28">
<dt><span class="spadfun">getArrows</span>: % -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> Record(name: <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>, arrType: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, fromOb: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, toOb: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, xOffset: <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>, yOffset: <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>, map: <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">getArrows(s)</span></code> returns a list of all the arrows (or edges)</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-676574566572746578496e646578"></span><dl class="simple" id="index-29">
<dt><span class="spadfun">getVertexIndex</span>: (%, S) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">getVertexIndex(s,</span> <span class="pre">o)</span></code> gives index of object <code class="docutils literal notranslate"><span class="pre">o</span></code>. returns 0 if not found</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6765745665727469636573"></span><dl class="simple" id="index-30">
<dt><span class="spadfun">getVertices</span>: % -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> Record(value: S, posX: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, posY: <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>)</dt><dd><p><code class="docutils literal notranslate"><span class="pre">getVertices(s)</span></code> returns a list of all the vertices (or objects) of the graph <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="l46696e6974654772617068-68617368">
<dt><a class="reference internal" href="SetCategory.html#l53657443617465676f7279-68617368"><span class="std std-ref">hash</span></a>: % -&gt; <a class="reference internal" href="SingleInteger.html#l53696e676c65496e7465676572"><span class="std std-ref">SingleInteger</span></a></dt><dd><p>from <a class="reference internal" href="SetCategory.html#l53657443617465676f7279"><span class="std std-ref">SetCategory</span></a></p>
</dd>
</dl>
<dl class="simple" id="l46696e6974654772617068-6861736855706461746521">
<dt><a class="reference internal" href="SetCategory.html#l53657443617465676f7279-6861736855706461746521"><span class="std std-ref">hashUpdate!</span></a>: (<a class="reference internal" href="HashState.html#l486173685374617465"><span class="std std-ref">HashState</span></a>, %) -&gt; <a class="reference internal" href="HashState.html#l486173685374617465"><span class="std std-ref">HashState</span></a></dt><dd><p>from <a class="reference internal" href="SetCategory.html#l53657443617465676f7279"><span class="std std-ref">SetCategory</span></a></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-696e636964656e63654d6174726978"></span><dl class="simple" id="index-31">
<dt><span class="spadfun">incidenceMatrix</span>: % -&gt; <a class="reference internal" href="Matrix.html#l4d6174726978"><span class="std std-ref">Matrix</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">incidenceMatrix(s)</span></code> represents graph <code class="docutils literal notranslate"><span class="pre">s</span></code> by a matrix of size <code class="docutils literal notranslate"><span class="pre">|V|</span></code> by <a href="#id1"><span class="problematic" id="id2">|E|</span></a> where: V=number of vertices E=number of edges entry [vertex, arrow] = arrow endpoint data (undirected case case: 1 - incident, 0 - not incident, directed case: <code class="docutils literal notranslate"><span class="pre">-1</span></code> - start, 1 - end, 0 - not incident).</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-696e446567726565"></span><dl class="simple" id="index-32">
<dt><span class="spadfun">inDegree</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">inDegree(s,</span> <span class="pre">a)</span></code> gives the number of arrows leading in to node ‘a’ in graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-696e697469616c"></span><dl class="simple" id="index-33">
<dt><span class="spadfun">initial</span>: () -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">initial</span> <span class="pre">constructs</span></code> a graph without vertices or edges</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6973416379636c69633f"></span><dl class="simple" id="index-34">
<dt><span class="spadfun">isAcyclic?</span>: % -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">isAcyclic?(s)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are no loops</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-697344697265637465643f"></span><dl class="simple" id="index-35">
<dt><span class="spadfun">isDirected?</span>: () -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p>isDirected? is <code class="docutils literal notranslate"><span class="pre">true</span></code> iff % is domain consisting of directed graphs, <code class="docutils literal notranslate"><span class="pre">false</span></code> for undirected graphs.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6973446972656374537563636573736f723f"></span><dl class="simple" id="index-36">
<dt><span class="spadfun">isDirectSuccessor?</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">isDirectSuccessor?(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">'b'</span></code> is a direct successor of ‘a’ that is, if there is a direct arrow from ‘a’ to <code class="docutils literal notranslate"><span class="pre">'b'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6973466978506f696e743f"></span><dl class="simple" id="index-37">
<dt><span class="spadfun">isFixPoint?</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">isFixPoint?(s,</span> <span class="pre">a)</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> if ‘a’ has an arrow to itself</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-697346756e6374696f6e616c3f"></span><dl class="simple" id="index-38">
<dt><span class="spadfun">isFunctional?</span>: % -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">isFunctional?(s)</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">s</span></code> is a functional graph, that is a directed graph in which each vertex has a single outgoing arrow.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6973477265617465725468616e3f"></span><dl class="simple" id="index-39">
<dt><span class="spadfun">isGreaterThan?</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">isGreaterThan?(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> if we can get from vertex ‘a’ to <code class="docutils literal notranslate"><span class="pre">'b'</span></code> through a sequence of arrows but we can<code class="docutils literal notranslate"><span class="pre">'t</span></code> go in the opposite direction from <code class="docutils literal notranslate"><span class="pre">'b'</span></code> to ‘a’</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6b6772617068"></span><dl class="simple" id="index-40">
<dt><span class="spadfun">kgraph</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> S, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">kgraph(objs,</span> <span class="pre">arrowName)</span></code> constructs a graph with vertices (from <code class="docutils literal notranslate"><span class="pre">objs</span></code>) and fully connected arrows, that is, each object has an arrow to every other object except itself. arrowName is a prefix for all arrow names, this will be followed by a number starting at 1 and incremented for each arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6c61706c616369616e4d6174726978"></span><dl class="simple" id="index-41">
<dt><span class="spadfun">laplacianMatrix</span>: % -&gt; <a class="reference internal" href="Matrix.html#l4d6174726978"><span class="std std-ref">Matrix</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">laplacianMatrix(s)</span></code> returns matrix also known as “Kirchhoff matrix” or “Admittance matrix” where: entry [<code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>] = inDegree(<code class="docutils literal notranslate"><span class="pre">vi</span></code>) if <code class="docutils literal notranslate"><span class="pre">i</span></code> = <code class="docutils literal notranslate"><span class="pre">j</span></code> (number of incoming links) <code class="docutils literal notranslate"><span class="pre">-1</span></code> if <code class="docutils literal notranslate"><span class="pre">i</span></code> not = <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">vi</span></code> is adjacent to <code class="docutils literal notranslate"><span class="pre">vj</span></code> 0 otherwise Alternatively this is defined as <code class="docutils literal notranslate"><span class="pre">D</span></code> - A, where <code class="docutils literal notranslate"><span class="pre">D</span></code> is the diagonal degree matrix. It contains both adjacency information and degree information. There are other, similar matrices, that are also called “Laplacian matrices” of a graph.</p>
</dd>
</dl>
<dl class="simple" id="l46696e6974654772617068-6c61746578">
<dt><a class="reference internal" href="SetCategory.html#l53657443617465676f7279-6c61746578"><span class="std std-ref">latex</span></a>: % -&gt; <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a></dt><dd><p>from <a class="reference internal" href="SetCategory.html#l53657443617465676f7279"><span class="std std-ref">SetCategory</span></a></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6c6f6f70734172726f7773"></span><dl class="simple" id="index-42">
<dt><span class="spadfun">loopsArrows</span>: % -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="Loop.html#l4c6f6f70"><span class="std std-ref">Loop</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">loopsArrows(s)</span></code> returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through. to-do: it would be better to use a more efficient algorithm, currently the code calls spanningForestArrow and traverses the result for loops, it might be more efficient to use Floyds algorithm.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6c6f6f707341744e6f6465"></span><dl class="simple" id="index-43">
<dt><span class="spadfun">loopsAtNode</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="Loop.html#l4c6f6f70"><span class="std std-ref">Loop</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">loopsAtNode(s,</span> <span class="pre">a)</span></code> returns a list of loops for this graph that pass through vertex index ‘a’</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6c6f6f70734e6f646573"></span><dl class="simple" id="index-44">
<dt><span class="spadfun">loopsNodes</span>: % -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="Loop.html#l4c6f6f70"><span class="std std-ref">Loop</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">loopsNodes(s)</span></code> returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6c6f6f7365457175616c73"></span><dl class="simple" id="index-45">
<dt><span class="spadfun">looseEquals</span>: (%, %) -&gt; <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">looseEquals(x,</span> <span class="pre">y)</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> ‘equals’ <code class="docutils literal notranslate"><span class="pre">y</span></code> this is a looser version of equality test but is not as general as isomorphism. it only requires the same number of vertices but does not require the objects themselves being equal. the arrows must be the same, that is it may return <code class="docutils literal notranslate"><span class="pre">false</span></code> if the order of vertices is changed so this is not isomorphism test.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6d6170"></span><dl class="simple" id="index-46">
<dt><span class="spadfun">map</span>: (%, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> S, <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>, <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">map(s,</span> <span class="pre">m,</span> <span class="pre">newOb,</span> <span class="pre">offsetX,</span> <span class="pre">offsetY)</span></code> creates a new graph by mapping from this one <code class="docutils literal notranslate"><span class="pre">newOb</span></code> should contain the new list of vertices. <code class="docutils literal notranslate"><span class="pre">m</span></code> should contain a NNI value for each vertex, this is the new index into <code class="docutils literal notranslate"><span class="pre">newOb</span></code>. It is allowed that <code class="docutils literal notranslate"><span class="pre">newOb</span></code> may contain less objects than <code class="docutils literal notranslate"><span class="pre">s</span></code> (for surjective mapping) or more objects than <code class="docutils literal notranslate"><span class="pre">s</span></code> (for injective mapping)</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6d6170436f6e747261"></span><dl class="simple" id="index-47">
<dt><span class="spadfun">mapContra</span>: (%, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> S, <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>, <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">mapContra(s,</span> <span class="pre">m,</span> <span class="pre">newOb,</span> <span class="pre">offsetX,</span> <span class="pre">offsetY)</span></code> is similar to map function but reverses the directions of the arrows</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6d6178"></span><dl class="simple" id="index-48">
<dt><span class="spadfun">max</span>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">max(s)</span></code> returns index of the vertex which can be reached from all other vertices. Gives 0 if no such node exists or if it is not unique, if there is a loop for instance.</p>
</dd>
</dl>
<dl class="simple" id="index-49">
<dt><span class="spadfun">max</span>: (%, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">max(s,</span> <span class="pre">sub)</span></code> returns index of the vertex which can be reached from a given subset of the vertices. Gives 0 if no such node exists or if it is not unique, if there is a loop for instance.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6d65726765"></span><dl class="simple" id="index-50">
<dt><span class="spadfun">merge</span>: (%, %) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">merge(a,</span> <span class="pre">b)</span></code> returns sum : union (not necessarily disjoint) of nodes with arrows merged in from appropriate input, if arrow exists from both inputs then it will be duplicated.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6d696e"></span><dl class="simple" id="index-51">
<dt><span class="spadfun">min</span>: % -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">min(s)</span></code> returns index of the vertex which can reach to all other vertices. Gives 0 if no such node exists or if it is not unique, if there is a loop for instance.</p>
</dd>
</dl>
<dl class="simple" id="index-52">
<dt><span class="spadfun">min</span>: (%, <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">min(s,</span> <span class="pre">sub)</span></code> returns index of the vertex which can reach to a given subset of the vertices. Gives 0 if no such node exists or if it is not unique, if there is a loop for instance.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6e6f646546726f6d4172726f77"></span><dl class="simple" id="index-53">
<dt><span class="spadfun">nodeFromArrow</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">nodeFromArrow(s,</span> <span class="pre">a)</span></code> returns index of all nodes with a direct arrow leading in to arrow ‘a’ in graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6e6f646546726f6d4e6f6465"></span><dl class="simple" id="index-54">
<dt><span class="spadfun">nodeFromNode</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">nodeFromNode(s,</span> <span class="pre">a)</span></code> gives list of all nodes with a direct arrow leading in to node ‘a’ in graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6e6f6465546f4172726f77"></span><dl class="simple" id="index-55">
<dt><span class="spadfun">nodeToArrow</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">nodeToArrow(s,</span> <span class="pre">a)</span></code> returns index of all nodes with a direct arrow leading out of arrow ‘a’ in graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6e6f6465546f4e6f6465"></span><dl class="simple" id="index-56">
<dt><span class="spadfun">nodeToNode</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">nodeToNode(s,</span> <span class="pre">a)</span></code> gives list of all nodes with a direct arrow leading out of node ‘a’ in graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-6f7574446567726565"></span><dl class="simple" id="index-57">
<dt><span class="spadfun">outDegree</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">outDegree(s,</span> <span class="pre">a)</span></code> gives the number of arrows leading out of node ‘a’ in graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-726f7574654172726f7773"></span><dl class="simple" id="index-58">
<dt><span class="spadfun">routeArrows</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">routeArrows(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> gives the shortest route between nodes ‘a’ and <code class="docutils literal notranslate"><span class="pre">'b'</span></code> as a sequence of arrow indexes. [] if ‘a’ = <code class="docutils literal notranslate"><span class="pre">'b'</span></code> [0] if it is not possible to go from ‘a’ to <code class="docutils literal notranslate"><span class="pre">'b'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-726f7574654e6f646573"></span><dl class="simple" id="index-59">
<dt><span class="spadfun">routeNodes</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">routeNodes(s,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> gives the shortest route between nodes ‘a’ and <code class="docutils literal notranslate"><span class="pre">'b'</span></code> as a sequence of node indexes. [a] if ‘a’ = <code class="docutils literal notranslate"><span class="pre">'b'</span></code> [] if it is not possible to go from ‘a’ to <code class="docutils literal notranslate"><span class="pre">'b'</span></code></p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-7370616e6e696e67466f726573744172726f77"></span><dl class="simple" id="index-60">
<dt><span class="spadfun">spanningForestArrow</span>: % -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="Tree.html#l54726565"><span class="std std-ref">Tree</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">spanningForestArrow(s)</span></code> constructs a spanning tree for every arrow.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-7370616e6e696e67466f726573744e6f6465"></span><dl class="simple" id="index-61">
<dt><span class="spadfun">spanningForestNode</span>: % -&gt; <a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> <a class="reference internal" href="Tree.html#l54726565"><span class="std std-ref">Tree</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">spanningForestNode(s)</span></code> constructs a spanning tree for every vertex.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-7370616e6e696e67547265654172726f77"></span><dl class="simple" id="index-62">
<dt><span class="spadfun">spanningTreeArrow</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Tree.html#l54726565"><span class="std std-ref">Tree</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">spanningTreeArrow(s,</span> <span class="pre">i)</span></code> constructs a spanning tree for graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code> rooted at the arrow indexed by ‘i’. The tree will expand out from ‘i’ only stopping when reaching a arrow that has already been visited (that is: loop detected). Elements in the tree are Integer, a positive Integer represents a arrow and a negative Integer represents a repeated arrow. note: it is possible that nodes may be visited many times, only arrows must not be re-visited.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-7370616e6e696e67547265654e6f6465"></span><dl class="simple" id="index-63">
<dt><span class="spadfun">spanningTreeNode</span>: (%, <a class="reference internal" href="NonNegativeInteger.html#l4e6f6e4e65676174697665496e7465676572"><span class="std std-ref">NonNegativeInteger</span></a>) -&gt; <a class="reference internal" href="Tree.html#l54726565"><span class="std std-ref">Tree</span></a> <a class="reference internal" href="Integer.html#l496e7465676572"><span class="std std-ref">Integer</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">spanningTreeNode(s,</span> <span class="pre">i)</span></code> constructs a spanning tree for graph <code class="docutils literal notranslate"><span class="pre">'s'</span></code> rooted at the node indexed by ‘i’. The tree will expand out from ‘i’ only stopping when reaching a vertex that has already been visited (that is: loop detected). Elements in the tree are Integer, a positive Integer represents a vertex and a negative Integer represents a repeated vertex.</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-7375626469616772616d537667"></span><dl class="simple" id="index-64">
<dt><span class="spadfun">subdiagramSvg</span>: (<a class="reference internal" href="Scene.html#l5363656e65"><span class="std std-ref">Scene</span></a> <a class="reference internal" href="SCartesian.html#l5343617274657369616e"><span class="std std-ref">SCartesian</span></a> 2, %, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>, <a class="reference internal" href="Boolean.html#l426f6f6c65616e"><span class="std std-ref">Boolean</span></a>) -&gt; <a class="reference internal" href="Void.html#l566f6964"><span class="std std-ref">Void</span></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">subdiagramSvg(sc,</span> <span class="pre">n,</span> <span class="pre">dispArrowName,</span> <span class="pre">deep)</span></code> creates a branch of an <code class="docutils literal notranslate"><span class="pre">SVG</span></code> diagram diagram under an already existing scene node <code class="docutils literal notranslate"><span class="pre">sc</span></code>. <code class="docutils literal notranslate"><span class="pre">n:</span></code> % is the graph that will be written dispArrowName: Boolean is <code class="docutils literal notranslate"><span class="pre">true</span></code> to include the name of each arrow</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-7465726d696e616c"></span><dl class="simple" id="index-65">
<dt><span class="spadfun">terminal</span>: S -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">terminal(a)</span></code> constructs a graph over a with a single vertex and a single loop</p>
</dd>
</dl>
<span class="target" id="l46696e6974654772617068-756e6974"></span><dl class="simple" id="index-66">
<dt><span class="spadfun">unit</span>: (<a class="reference internal" href="List.html#l4c697374"><span class="std std-ref">List</span></a> S, <a class="reference internal" href="String.html#l537472696e67"><span class="std std-ref">String</span></a>) -&gt; %</dt><dd><p><code class="docutils literal notranslate"><span class="pre">unit(objs,</span> <span class="pre">arrowName)</span></code> constructs a graph with vertices (from <code class="docutils literal notranslate"><span class="pre">objs</span></code>) and arrows from each object to itself. arrowName is a prefix for all arrow names, this will be followed by a number starting at 1 and incremented for each arrow</p>
</dd>
</dl>
<p><a class="reference internal" href="BasicType.html#l426173696354797065"><span class="std std-ref">BasicType</span></a></p>
<p><a class="reference internal" href="CoercibleTo.html#l436f65726369626c65546f"><span class="std std-ref">CoercibleTo</span></a> <a class="reference internal" href="OutputForm.html#l4f7574707574466f726d"><span class="std std-ref">OutputForm</span></a></p>
<p><a class="reference internal" href="SetCategory.html#l53657443617465676f7279"><span class="std std-ref">SetCategory</span></a></p>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FriCAS API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="FiniteGroup.html" title="FiniteGroup"
             >next</a> |</li>
        <li class="right" >
          <a href="FiniteFieldCategory.html" title="FiniteFieldCategory"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FriCAS</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >FriCAS API</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="Categories.html" >Categories</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">FiniteGraph S</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2020, FriCAS Team.
    </div>
  </body>
</html>